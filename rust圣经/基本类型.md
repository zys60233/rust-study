## 数值类型

### 整数类型

| 长度       | 有符号类型    | 无符号类型 |
| ---------- | ------------- | ---------- |
| 8位        | i8            | u8         |
| 16位       | i16           | u16        |
| 32位       | i32（默认值） | u32        |
| 64位       | i64           | u64        |
| 128位      | i128          | u128       |
| 视架构而定 | isize         | usize      |
|            |               |            |

> 整型溢出时，debug模式下会使程序崩溃而退出，release模式下不检测溢出，会按照补码循环溢出规则处理。
>
> 显示处理可能的溢出：
>
> - 使用`wrapping_*`方法在所有模式下都按照补码循环溢出规则处理；
> - 使用`checked_*`方法处理溢出，则返回`None`值；
> - 使用`overflowing_*`方法返回该值和一个指示是否存在溢出的布尔值；
> - 使用`saturating_*`方法使值达到最小值或最大值；



### 浮点类型

| 精度   | 类型        |
| ------ | ----------- |
| 单精度 | f32         |
| 双精度 | f64（默认） |

> 浮点类型使用需要遵守的准则：
>
> - 避免在浮点数上测试相等性；
> - 当结果在数学上可能存在未定义时，需要格外小心；



### NaN

> 所有跟`NaN`交互的操作，都会返回一个`NaN`，而且`NaN`不能用来比较。



### 数字运算

```rust
//基本数学运算：加法、减法、乘法、除法和取模运算，只有同类型可以运算
let sum = 5 + 10;

let difference = 95.5 - 4.3;

let product = 4 * 30;

let quotient = 56.7 / 32.2;

let remainder = 43 % 5;
```



### 位运算

| 运算符   | 说明                                                   |
| -------- | ------------------------------------------------------ |
| & 位与   | 相同位置均为1时则为1，否则为0                          |
| \|  位或 | 相同位置只要有1时则为1，否则为0                        |
| ^ 异或   | 相同位置不相同则为1，相同则为0                         |
| !  位非  | 把位中的0和1相互取反，即0置为1，1置为0                 |
| << 左移  | 所有位向左移动指定位数，右位补0                        |
| >> 右移  | 所有位向右移动指定位数，带符号移动（正数补0，负数补1） |



### 序列（Range）

```rust
//生成连续的数值
for i in 1..5 {}	//不包含5

for i in 1..=5 {}	//包含5

for i in 'a'..='z' {}	//包含z
```



### 有理数和复数

```rust
//rust数值库：num
//引入：在Cargo.toml中的[dependencies]下添加一行 num = "0.4.0"

use num::complex::Complex;
fn main {
  let a = Complex {2.1, -1.2};
  let b = Complex::new(11.1, 22.2);
}
```



### 总结

- **Rust拥有相当多的数值类型；**
- **类型转换必须时显式的；**
- **Rust的数值上可以使用方法。**



## 字符、布尔、单元类型

### 字符类型（char）

```rust
let char = 'abc';
```



### 布尔

```rust
let t = true;
let f = false;
```



## 单元类型

> 单元类型就是()



## 语句和表达式

### 语句

> 定义：完成了一个具体操作，但是没有返回值。

```rust
//语句示例
let x = 5;

let y = x + 5;
```



### 表达式

> 定义：会进行求值，然后返回一个值。==表达式不能以分号结尾。==

```rust
//表达式示例
x + 5

Y + 1
```



## 函数

<img src="D:\notebook\rust-stury\image\v2-54b3a6d435d2482243edc4be9ab98153_1440w.png" alt="函数定义图片" style="zoom:200%;" />

### 函数要点

- 函数名和变量名使用蛇形命名法；
- 函数的位置可以随便放，Rust不关心我们在哪里定义的函数，只要有定义即可；
- 每个函数参数都需要标注类型。

### 函数参数

> Rust是强类型语言，因此需要为每一个函数参数标识出它的具体类型。

### 函数返回

> Rust中函数就是表达式，因此可以把函数的返回值直接赋给调用者。
>
> 函数的返回值就是函数体最后一条表达式的返回值，当然我们也可以使用`return`提前返回。

```rust
fn plus_five(x:i32) -> i32 {
    x + 5
}
```

#### Rust中的特殊返回类型

> 单元类型`()`，是一个零长度的元组。它没啥作用，但是可以用来表达一个函数没有返回值：
>
> - 函数没有返回值，那么返回一个`()`；
> - 通过`;`结尾的表达式返回`()`；

```rust
fn report<T: Debug>(item: T) {
    println!("{:?}", item);
}

fn report<T: Debug>(item: T) -> () {
    println!("{:?}", item);
}

//以上两种效果相同
```

> 当用`!`做函数的返回类型时，标识该函数永不返回，称为**永不返回的发散函数**。

```rust
fn dead_end() -> ! {
    panic!("你已经到了穷途末路了，崩溃吧！");
}
```

